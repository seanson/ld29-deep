// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;


public class PlayerInput : FNode, FSingleTouchableInterface {
	public bool touchActive = false;
	public Vector2 touchPosition;
	public PlayerInput() {
		this.EnableSingleTouch();
	}

	public bool HandleSingleTouchBegan(FTouch touch) {
		touchPosition = touch.position;
		touchActive = true;
		return true;
	}
	public void HandleSingleTouchMoved(FTouch touch){
		touchPosition = touch.position;
	}
	
	public void HandleSingleTouchEnded(FTouch touch){
		touchActive = false;
	}
	
	public void HandleSingleTouchCanceled(FTouch touch){
		touchActive = false;
	}

	public void update() {
		PlayerState.SWIM_LEFT = false;
		PlayerState.SWIM_RIGHT = false;

		if (Input.GetKey ("left") || Input.GetKey ("a")) {
			PlayerState.SWIM_LEFT = true;
			touchActive = false;
		}

		if (Input.GetKey("right") || Input.GetKey ("d")) {
			PlayerState.SWIM_RIGHT = true;
			touchActive = false;
		}

		if (touchActive) {
			if (touchPosition.x > PlayerState.player.x + 10.0f) {
				PlayerState.SWIM_RIGHT = true;
			}
			else if (touchPosition.x < PlayerState.player.x - 10.0f) {
				PlayerState.SWIM_LEFT = true;
			}
		}
	}

}

public class EnemyController
{
	public float lastSpawn = 0.0f;
	public float lastDepth = 50.0f;
	public float requiredDepth = 50.0f;
	public float requiredTime = 5.0f;
	public List<string> enemyTypes = new List<string> {"fish_swim", "eel", "jewel"};
	public List<EnemySprite> removeList = new List<EnemySprite>();
	private System.Random _rand = new System.Random();
	public EnemyController() {
	}

	public void spawnEnemy(String type) {
		EnemySprite enemySprite = new EnemySprite(type);
		Level.enemyList.Add(enemySprite);
		Futile.stage.AddChild(enemySprite);

	}

	public void update(float delta) {
		foreach (EnemySprite enemy in Level.enemyList) {
			enemy.update(delta);
			if (enemy.y > 300.0f) {
				this.removeList.Add(enemy);
			}
			if (enemy.collRect.CheckIntersect(PlayerState.player.collRect)) {
				if (PlayerState.player.collide(enemy))
				{
					this.removeList.Add(enemy);
				}
			}
		}
		foreach (EnemySprite enemy in this.removeList) {
			Level.enemyList.Remove(enemy);
			Futile.stage.RemoveChild(enemy);
		}
		this.removeList.Clear ();
		requiredTime = 3.0f - (PlayerState.DEPTH * 0.001f);
		requiredDepth = 50.0f - (PlayerState.DEPTH * 0.01f);
		if ((Time.realtimeSinceStartup - this.lastSpawn > requiredTime) && (PlayerState.DEPTH - this.lastDepth > requiredDepth)) {
			string enemyType = this.enemyTypes[this._rand.Next(this.enemyTypes.Count)];
			Debug.Log ("Enough time and depth has passed, spawning: " + enemyType);
			this.spawnEnemy(enemyType);
			this.lastSpawn = Time.realtimeSinceStartup;
			this.lastDepth = PlayerState.DEPTH;
		}
	}
}
